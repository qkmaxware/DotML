@using DotML
@using DotML.Network
@using DotML.Network.Training

@if (Network is not null) {
<div class="horizontal">
    <div class="layer">
        <div style="text-align: center;">
            <label>Input Layer</label>
        </div>
        <hr>
        <VectorizedImage Width=@Network.InputImageWidth Height=@Network.InputImageHeight ValueScale=@ValueScale Vector=@selected?.Input></VectorizedImage>
        <div style="text-align:  center;">
            <button type="button" class="btn btn-primary" @onclick=prev>Prev.</button>
            <button type="button" class="btn btn-primary" @onclick=next>Next</button>
            <button type="button" class="btn btn-primary" @onclick=compute_images>Refresh</button>
        </div>
    </div>
    @if (this.inputs is not null && this.outputs is not null) {
        for (var layerIndex = 0; layerIndex < Math.Min(this.inputs.Length, this.outputs.Length); layerIndex++) {
            var output = outputs[layerIndex];
            var layer = this.Network.GetLayer(layerIndex);
            <div class="layer">
                    <div style="text-align: center;">
                        <label>Layer @layerIndex</label>
                    </div>
                    @for (var outputIndex = 0; outputIndex < output.Length; outputIndex++) {
                        var o_i = output[outputIndex];
                        var o_vec = Vec<double>.Wrap(o_i.FlattenRows().ToArray());
                        @if (layer is not FullyConnectedLayer full && layer is not SoftmaxLayer softmax) {
                            <hr>
                            <label>Output @outputIndex</label><br>
                            <VectorizedImage Width=@o_i.Columns Height=@o_i.Rows ValueScale=@ValueScale Vector=@o_vec></VectorizedImage>
                        }  else {
                            <VectorTable TValue=double Vector=@o_vec></VectorTable>
                        }
                    }
            </div>
        }
    }
</div>
}

@code {
    [Parameter] public ConvolutionalFeedforwardNetwork? Network {get; set;} = null;
    [Parameter] public TrainingSet? Data {get; set;} = null;
    [Parameter] public int ValueScale {get; set;} = 1;

    private int current_index = 0;

    private void prev() {
        if (this.Data is null)
            return;
        if (current_index > 0) {
            current_index--;
            compute_images();
        }
    }
    private void next() {
        if (this.Data is null)
            return;
        if (current_index < this.Data.Size - 1) {
            current_index++;
            compute_images();
        }
    }

    TrainingPair? selected => this.Data is not null && current_index >= 0 && current_index < this.Data.Size ? this.Data[current_index] : null;

    Matrix<double>[][]? inputs; // The inputs to each layer
    Matrix<double>[][]? outputs; // The outputs from each layer

    private void compute_images() {
        try {
            var current = selected;
            if (current is null || this.Network is null)
                return;

            var input = current.Input.Shape(
                new Shape(this.Network.InputImageHeight, this.Network.InputImageWidth), 
                this.Network.InputImageChannels
            ).ToArray();
            var expected = current.Output;

            // Forward pass (simulated, duplicate of ConvolutionalFeedforwardNetwork.PredictSync with some additional tracking)
            this.inputs   = new Matrix<double>[this.Network.LayerCount][]; // The inputs to each layer
            this.outputs  = new Matrix<double>[this.Network.LayerCount][]; // The outputs from each layer

            Matrix<double>[] layer_input = input;
            for (var layerIndex = 0; layerIndex < this.Network.LayerCount; layerIndex++) {
                inputs[layerIndex] = layer_input;
                var layer = this.Network.GetLayer(layerIndex);
                var layer_output = layer.EvaluateSync(layer_input);
                outputs[layerIndex] = layer_output;
                layer_input = layer_output;
            }
            var actual = layer_input;
        } catch {}
    }

}