@using DotML
@using DotML.Network
@using DotML.Network.Training

<div class="p-4">
    <h3>Input</h3>
    <div class="row">
        <div class="col">
            <div class="form-group">
                <label>Image Width:</label>
                <input type="number" class="form-control" @bind=img_width>
                <label>Image Height:</label>
                <input type="number" class="form-control" @bind=img_height>
                <label>Image Channels:</label>
                <input type="number" class="form-control" @bind=img_channels>
            </div>
        </div>
        <div class="col">
            <label>Shape: </label><br>
            @img_channels x @img_width x @img_height (@(img_channels * img_width * img_height))
            <br><label>Size: </label><br>
            @((sizeof(double) * img_channels * img_width * img_height)/1e+6)MB
        </div>
    </div>

    <ol class="list-group list-group-numbered">
        @for (var layerIndex = 0; layerIndex < layers.Count; layerIndex++) {
            var layer = layers[layerIndex];
            var input = inputs is not null && inputs.Length > layerIndex ? inputs[layerIndex] : null;
            var output = outputs is not null && outputs.Length > layerIndex ? outputs[layerIndex] : null;
            <li>
                <h3>@layer.Name</h3><br>
                <div class="row">
                <div class="col">
                    @switch(layer){
                        case ConvoLayerArgs convo:
                            <label>Padding: (controls output size)</label>
                            <select class="form-control" @bind=convo.Padding>
                                @foreach (var value in Enum.GetValues<Padding>()) {
                                    <option>@value</option>
                                }
                            </select>
                            <label>Filters: (number of output channels)</label>
                            <input type="number" class="form-control" @bind=convo.FilterCount>
                            <label>Kernels/Filter: (should equal the number of input channels)</label>
                            <input type="number" class="form-control" @bind=convo.KernelsPerFilter>
                            <label>Kernel Size: </label>
                            <input type="number" class="form-control" @bind=convo.KernelSize>
                            <label>Horizontal Stride: </label>
                            <input type="number" class="form-control" @bind=convo.XStride>
                            <label>Vertical Stride: </label>
                            <input type="number" class="form-control" @bind=convo.YStride>
                            break;
                        case PoolingArgs pool:
                            <label>Algorithm: </label>
                            <select class="form-control" @bind=pool.Algorithm>
                                @foreach (var value in Enum.GetValues<PoolType>()) {
                                    <option>@value</option>
                                }
                            </select>
                            <label>Filter Width: </label>
                            <input type="number" class="form-control" @bind=pool.Width>
                            <label>Filter Height: </label>
                            <input type="number" class="form-control" @bind=pool.Height>
                            <label>Horizontal Stride: </label>
                            <input type="number" class="form-control" @bind=pool.XStride>
                            <label>Vertical Stride: </label>
                            <input type="number" class="form-control" @bind=pool.YStride>
                            break;
                        case FullConnArgs connect:
                            <label>Input Neurons: (should equal the flattened outputs of prev. layer)</label>
                            <input type="number" class="form-control" @bind=connect.Inputs>
                            <label>Output Neurons: </label>
                            <input type="number" class="form-control" @bind=connect.Outputs>
                            break; 
                    }
                </div>
                <div class="col">
                    <label>Shape: </label><br>
                    @if (input is not null && input.Length > 0) {
                        <span>@input.Length x @input[0].Rows x @input[0].Columns (@(input[0].Rows * input[0].Columns * input.Length))</span>
                    } else {
                        <span>?</span>
                    } &rightarrow; 
                    @if (output is not null && output.Length > 0) {
                        <span>@output.Length x @output[0].Rows x @output[0].Columns (@(output[0].Rows * output[0].Columns * output.Length))</span>
                    } else {
                        <span>?</span>
                    }
                    <br><label>Parameters: </label><br>
                    @layer.ParamCount()
                    <br><label>Size: </label><br>
                    @((sizeof(double) * layer.ParamCount())/1e+6)MB
                </div>
                </div>
            </li>
        }
    </ol>
    @if (error is not null) {
        <div class="alert alert-danger" role="alert" style="margin-top: 24px;">
            @error
        </div>
    }
    <div style="margin-top: 24px;">
    <button type="button" class="btn" @onclick=@(() => layers.Add(new ConvoLayerArgs()))>+ Convolution</button>
    <button type="button" class="btn" @onclick=@(() => layers.Add(new PoolingArgs()))>+ Pooling</button>
    <button type="button" class="btn" @onclick=@(() => layers.Add(new FullConnArgs()))>+ Fully Connected</button>
    <button type="button" class="btn" @onclick=@(() => layers.RemoveAt(layers.Count - 1))>-</button>
    | 
    <button type="button" class="btn btn-primary" @onclick=Compute>Compute Sizes</button>
    </div>
</div>
@code {

    private int img_width = 256;
    private int img_height = 256;
    private int img_channels = 3;

    abstract class LayerArgs {
        public abstract string Name {get;}
        public abstract ConvolutionalFeedforwardNetworkLayer Make();
        public abstract int ParamCount();
    }

    class ConvoLayerArgs : LayerArgs{
        public override string Name => "Convolutional Layer";
        public Padding Padding;
        public int FilterCount = 1;
        public int KernelsPerFilter = 1;
        public int KernelSize = 3;

        public int XStride = 1;
        public int YStride = 1;

        public override int ParamCount() => KernelSize * KernelSize * KernelsPerFilter * FilterCount;

        public override ConvolutionalFeedforwardNetworkLayer Make() {
            return new ConvolutionLayer(
                Padding, 
                XStride, YStride,
                Enumerable
                    .Range(0, FilterCount)
                    .Select(filter => new ConvolutionFilter(
                        Enumerable
                            .Range(0, KernelsPerFilter)
                            .Select(kernel => Kernels.RandomKernel(KernelSize))
                            .ToArray()
                    ))
                    .ToArray()
            );
        }
    }

    enum PoolType { Max, Avg }

    class PoolingArgs : LayerArgs {
        public override string Name => "Pooling Layer";
        public PoolType Algorithm;
        public int Width = 3;
        public int Height = 3;
        public int XStride = 1;
        public int YStride = 1;

        public override int ParamCount() => 0;

        public override ConvolutionalFeedforwardNetworkLayer Make() {
            if (Algorithm == PoolType.Avg) {
                return new LocalAvgPoolingLayer(Width, Height, XStride, YStride);
            } else {
                return new LocalMaxPoolingLayer(Width, Height, XStride, YStride);
            }
        }
    }

    class FullConnArgs : LayerArgs {
        public override string Name => "Fully Connected Layer";
        public int Inputs;
        public int Outputs;

        public override int ParamCount() => Inputs * Outputs + Outputs;

        public override ConvolutionalFeedforwardNetworkLayer Make() {
            return new FullyConnectedLayer(Inputs, Outputs);
        }
    }

    private List<LayerArgs> layers = new List<LayerArgs>{

    };

    private Random rng = new Random();

    private Matrix<double>[] MakeInitial() {
        return 
            Enumerable
            .Range(0, img_channels)
            .Select(channel => Matrix<double>.Generate(img_height, img_width, rng.NextDouble))
            .ToArray();
    }

    private Matrix<double>[][]? inputs;
    private Matrix<double>[][]? outputs;
    private Exception? error;
    private void Compute() {
        error = null;
        var network = new ConvolutionalFeedforwardNetwork(
            img_width, img_height, img_channels,
            layers.Select(args => args.Make()).ToArray()
        );

        inputs   = new Matrix<double>[network.LayerCount][];
        outputs  = new Matrix<double>[network.LayerCount][];

        var input = MakeInitial();

        Matrix<double>[] layer_input = input;
        try {
            for (var layerIndex = 0; layerIndex < network.LayerCount; layerIndex++) {
                inputs[layerIndex] = layer_input;
                var layer = network.GetLayer(layerIndex);
                var layer_output = layer.EvaluateSync(layer_input);
                outputs[layerIndex] = layer_output;
                layer_input = layer_output;
            }
        } catch (Exception e) {
            error = e;
        }
    }
}    