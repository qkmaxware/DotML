@using Qkmaxware.Media.Image

@inject IJSRuntime js

<div class="canvas-container">
    <canvas @ref="canvas" width="@ImgWidth" height="@ImgHeight" @onmouseup=canvas_changed></canvas>
    <button class="btn delete" @onclick=Clear>&times; Clear</button>
    <div class="transfer @(transferring ? "show" : "hide")">
        transferring data...
    </div>
</div>
<div class="controls-container">
    <label>Import image </label>
    <input @ref="import_input" type="file" accept="image/*" capture="environment">
</div>

@code {
    [Parameter] public int ImgWidth {get; set;} = 32;
    [Parameter] public int ImgHeight {get; set;} = 32;
    [Parameter] public Action<Pixel[]>? OnChange {get; set;}
    private ElementReference? canvas;
    private ElementReference? import_input;

    private bool transferring = false;

    protected override void OnAfterRender(bool firstRender) {
        if (!firstRender)
            return;

        js.InvokeVoidAsync("BlazorComponents.PaintApp.init", canvas, ImgWidth, ImgHeight, import_input);
    }

    public void Clear() {
        js.InvokeVoidAsync("BlazorComponents.PaintApp.clear", canvas);
        canvas_changed();
        StateHasChanged();
    }

    public async Task<IImage> GetImage() {
        var pixels = await streamPixels();
        var image = new MemoryImage(ImgWidth, ImgHeight);
        if (image.Pixels is null)
            return image;
        
        var index = 0;
        for (var i = 0; i < ImgHeight; i++) {
            for (var j = 0; j < ImgWidth; j++) {
                image.Pixels[i, j] = pixels[index++];
            }
        }
        return image;
    }

    private async Task<Pixel[]> streamPixels() {
        transferring = true;
        await InvokeAsync(StateHasChanged);

        var tcs = new TaskCompletionSource<Pixel[]>();
        JsStream stream = new JsStream(this.ImgHeight * this.ImgWidth * 3);
        var writer = stream.GetJsWriter();
        stream.OnStreamFlush += (pixeldata) => {
            const int values_per_pixel = 3;
            var pixels = new Pixel[pixeldata.Count / values_per_pixel];

            for (int i = 0, j = 0, n = pixeldata.Count; i < n; i += values_per_pixel, j++) {
                pixels[j] = new Pixel(
                    r: pixeldata[i],
                    g: pixeldata[i + 1],
                    b: pixeldata[i + 2]
                    // Alpha would be i+3
                );
            }

            writer.Dispose();
            tcs.SetResult(pixels);
        };
        CancellationTokenSource source = new CancellationTokenSource(TimeSpan.FromMinutes(4));
        await js.InvokeVoidAsync(
            "BlazorComponents.PaintApp.stream_pixels", 
            source.Token,
            canvas, 
            writer, 
            ImgWidth, 
            ImgHeight
        );
        var px = await tcs.Task;

        transferring = false;
        await InvokeAsync(StateHasChanged);
        
        return px;
    }

    private async Task<Pixel[]> getPixels() {
        transferring = true;
        await InvokeAsync(StateHasChanged);
        
        CancellationTokenSource source = new CancellationTokenSource(TimeSpan.FromMinutes(4));
        var pixeldata = await js.InvokeAsync<byte[]>(
            "BlazorComponents.PaintApp.get_pixels", 
            source.Token,
            canvas,  
            ImgWidth, 
            ImgHeight
        );
        const int values_per_pixel = 3;
        var pixels = new Pixel[pixeldata.Length / values_per_pixel];

        for (int i = 0, j = 0, n = pixeldata.Length; i < n; i += values_per_pixel, j++) {
            pixels[j] = new Pixel(
                r: pixeldata[i],
                g: pixeldata[i + 1],
                b: pixeldata[i + 2]
                // Alpha would be i+3
            );
        }

        transferring = false;
        await InvokeAsync(StateHasChanged);
        
        return pixels;
    }

    private async void canvas_changed() {
        if (OnChange is not null) {
            OnChange.Invoke(await streamPixels());
        }
    }
}