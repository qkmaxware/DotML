@using DotML
@using DotML.Network
@using DotML.Network.Training

<CnnDataVisualizer Network=@Network ValueScale=@ValueScale Input=@selected?.Input>
    <Header>
        <button type="button" class="btn btn-primary" @onclick=prev>Prev.</button>
        <button type="button" class="btn btn-primary" @onclick=next>Next</button>
    </Header>
</CnnDataVisualizer>

@code {
    [Parameter] public ConvolutionalFeedforwardNetwork? Network {get; set;} = null;
    [Parameter] public TrainingSet? Data {get; set;} = null;
    [Parameter] public int ValueScale {get; set;} = 1;

    private int current_index = 0;

    private void prev() {
        if (this.Data is null)
            return;
        if (current_index > 0) {
            current_index--;
            compute_images();
        }
    }
    private void next() {
        if (this.Data is null)
            return;
        if (current_index < this.Data.Size - 1) {
            current_index++;
            compute_images();
        }
    }

    TrainingPair? selected => this.Data is not null && current_index >= 0 && current_index < this.Data.Size ? this.Data[current_index] : null;

    Matrix<double>[][]? inputs; // The inputs to each layer
    Matrix<double>[][]? outputs; // The outputs from each layer

    private void compute_images() {
        try {
            var current = selected;
            if (current is null || this.Network is null)
                return;

            var input = current.Input.Shape(
                new Shape2D(this.Network.InputImageHeight, this.Network.InputImageWidth), 
                this.Network.InputImageChannels
            ).ToArray();
            var expected = current.Output;

            // Forward pass (simulated, duplicate of ConvolutionalFeedforwardNetwork.PredictSync with some additional tracking)
            this.inputs   = new Matrix<double>[this.Network.LayerCount][]; // The inputs to each layer
            this.outputs  = new Matrix<double>[this.Network.LayerCount][]; // The outputs from each layer

            Matrix<double>[] layer_input = input;
            for (var layerIndex = 0; layerIndex < this.Network.LayerCount; layerIndex++) {
                inputs[layerIndex] = layer_input;
                var layer = this.Network.GetLayer(layerIndex);
                var layer_output = layer.EvaluateSync(layer_input);
                outputs[layerIndex] = layer_output;
                layer_input = layer_output;
            }
            var actual = layer_input;
        } catch {}
    }

}