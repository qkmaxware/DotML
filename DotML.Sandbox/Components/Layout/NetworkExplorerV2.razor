@typeparam TNetwork where TNetwork:INeuralNetwork
@using DotML
@using DotML.Network
@using DotML.Network.Initialization
@using DotML.Network.Training
@using System.Timers
@using System.Diagnostics
@using System.Text.Json
@using System.Text.Json.Serialization
@inject IJSRuntime js
@inject NavigationManager nav
@implements IDisposable

<nav class="bg-dark text-light">
    <div class="tab @(state == State.Playground ? "bg-info" : string.Empty)" @onclick=@(() => state = State.Playground)>Play</div>
    @if (true || TrainingData is not null) {
    <div class="tab @(state == State.Training ? "bg-info" : string.Empty)" @onclick=@(() => state = State.Training)>Train</div>
    }
</nav>
@if(state == State.Training ) {
<nav id="Training Controls" class="p-4 navbar navbar-inverse text-light bg-secondary">
    <div style="width: 100%; display:block flex; align-items: stretch;">
        <div style="text-align: center; width: 270px; flex-grow: 0; flex-shrink: 0;">
            <div>
                <button title="Reset Training" type="button" class="btn btn-light circle-small" @onclick=reset_training>&#8635;</button>
                <button title="Play/Pause Training" type="button" class="btn btn-primary circle-large" @onclick=play_pause>@if(step_timer is null || !step_timer.Enabled){<text>&#9658;</text>}else{<text>||</text>}</button>
                <button title="Cancel Training" type="button" disabled="@((step_timer is null || !step_timer.Enabled))" class="btn btn-danger circle-small" @onclick=cancel_training>&times;</button>
                <button title="Next Epoch" type="button" class="btn btn-light circle-small" @onclick=step_training>&#x21B7;</button>
                <TrainingProgress @ref=training_progress></TrainingProgress>
                <button type="button" class="btn btn-primary" style="width: 100%; margin-top: 6px;" @onclick=complete_training>
                    Complete Training
                </button>
            </div>
        </div>
        <div style="width: calc(100% - 270px); flex-grow: 1; flex-shrink: 1;">
            <label><b>Trainer Options:</b></label>
            <div>
                @if (Network is INamedNetwork named && !string.IsNullOrEmpty(named.Name)) {
                    <text>Name: @named.Name, </text>
                }
                Parameter size: @(sizeof(double))bytes, Trainable parameters: @Network?.TrainableParameterCount(), Size on disk: @(((Network?.TrainableParameterCount() ?? 0.0) * sizeof(double) / 1e9).ToString("F4"))Gb
            </div>
            <div class="horizontal">
                @if (Trainer is not null) {
                foreach(var property in Trainer.GetType().GetProperties()) {
                if (property.GetSetMethod() is not null && property.GetGetMethod() is not null) {
                    <div class="form-group">
                        <PropertyBinding Owner=Trainer Property=property></PropertyBinding>
                    </div>
                }}}
                @if(TrainingParams is not null && Network is not null && Trainer is not null) {
                    @TrainingParams((Network, Trainer))
                }
            </div>
        </div>
    </div>
</nav>
@if (step_error is not null) {
    <div class="alert alert-danger" role="alert">
        <pre>
            @step_error
        </pre>
    </div>
}
<div class="p-4">
    <div class="row">
        <div id="Training Data" class="col-sm" style="overflow-x: auto;">
            <label class="header">Data</label>
            <label>Training Data</label>
            <div style="text-align: right;">
                <button type="button" class="btn" style="text-decoration: underline;" @onclick=@(() => download(TrainingData))>json</button>
                <button type="button" class="btn" style="text-decoration: underline;" @onclick=@(() => download_binary(TrainingData))>bin</button>
            </div>
            <div>
                @if (TrainingData is not null) {
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Input</th>
                                <th>Output</th>
                            </tr>
                        </thead>
                        <tbody>
                                @for (var i = 0; i < Math.Min(TrainingData.Size, MAX_SET_DISPLAY_SIZE); i++) {
                                    var pair = TrainingData[i];
                                    <tr>
                                        @if(pair.Input.Dimensionality <= MAX_VECTOR_LENGTH) {
                                            <td title="@pair.Input" class="titled">@pair.Input</td>
                                        } else {
                                            <td>[...]</td>
                                        }
                                        @if (pair.Output.Dimensionality <= MAX_VECTOR_LENGTH) {
                                            <td title="@pair.Output" class="titled">@pair.Output</td>
                                        } else {
                                            <td>[...]</td>
                                        }
                                    </tr>
                                }
                        </tbody>
                    </table>
                    if (TrainingData.Size > MAX_SET_DISPLAY_SIZE) {
                        <p>Training set contains @TrainingData.Size pairs which is too large for all of them to be displayed. Download the training data via the get button above to view all vectors.</p>
                    }
                }
                @if (TrainingData is not null && DataVisualization is not null) {
                    @DataVisualization(TrainingData)
                }
            </div>
            <div class="divider"></div>
            <label>Validation Data</label>
            <div style="text-align: right;">
                <button type="button" class="btn" style="text-decoration: underline;" @onclick=@(() => download(validation_data))>json</button>
                <button type="button" class="btn" style="text-decoration: underline;" @onclick=@(() => download_binary(validation_data))>bin</button>
            </div>
            <div>   
                @if (validation_data is not null) {
                    var data = validation_data;
                    <table class="table">
                        <thead>
                            <tr>
                                <th>Input</th>
                                <th>Output</th>
                            </tr>
                        </thead>
                        <tbody>
                                @for (var i = 0; i < Math.Min(data.Size, MAX_SET_DISPLAY_SIZE); i++) {
                                    var pair = data[i];
                                    <tr>
                                        @if(pair.Input.Dimensionality <= MAX_VECTOR_LENGTH) {
                                            <td title="@pair.Input" class="titled">@pair.Input</td>
                                        } else {
                                            <td>[...]</td>
                                        }
                                        @if (pair.Output.Dimensionality <= MAX_VECTOR_LENGTH) {
                                            <td title="@pair.Output" class="titled">@pair.Output</td>
                                        } else {
                                            <td>[...]</td>
                                        }
                                    </tr>
                                }
                        </tbody>
                    </table>
                    if (data.Size > MAX_SET_DISPLAY_SIZE) {
                        <p>Validation set contains @data.Size pairs which is too large for all of them to be displayed. Download the training data via the get button above to view all vectors.</p>
                    }
                }
                @if (validation_data is not null && DataVisualization is not null) {
                    @DataVisualization(validation_data)
                }
            </div>
        </div>
        <div id="Network State" class="col-sm" style="overflow-x: auto;">
            <label class="header">Network</label>
            <figure>
                <figcaption>Weights</figcaption>
                <div style="text-align: right;">
                    @if (Network is ISafetensorable safeable) {
                        <button type="button" class="btn" style="text-decoration: underline;" @onclick=@(() => download_bytes(safeable.ToSafetensor(), "network.safetensors"))>bin</button>
                    }
                    @if (Network is IJsonizable jsonizable) {
                        <button type="button" class="btn" style="text-decoration: underline;" @onclick=@(() => download_str(jsonizable.ToJsonOrDefault("null"), "network.json"))>json</button>
                    }
                </div>
                @if (Network is ISafetensorable) {
                    <p><b>Safetensors</b> is a simple binary format for the storage of tensor data for safe distribution. Download all tensors related to this network by pressing the "bin" button above.</p>
                }
                @if (Network is IJsonizable) {
                    <p><b>JSON</b> is a human readable/writeable interchange format. Download the JSON representation of this network by pressing the "json" button above.</p>
                }
            </figure>
            <div class="divider"><hr></div>
            
            @if (NetworkVisualization is not null && Network is not null) {
                <label>Network Digram</label>
                @NetworkVisualization(Network)
            }
        </div>
        <div id="Training Results" class="col-sm" style="overflow-x: auto;">
            <label class="header">Validation</label>
            <figure style="overflow: auto;">
                <figcaption>Loss vs Epoch</figcaption>
                <div class="col" style="text-align: right;">
                    <button type="button" class="btn" style="text-decoration: underline;" onclick="BlazorComponents.Files.download('loss-vs-epoch.svg', 'image/svg+xml', new TextEncoder().encode(document.getElementById('training-loss-graph').outerHTML));">svg</button>
                </div>
                <Plot Id="training-loss-graph" Data=loss_graph YAxisLabel="Loss" XAxisLabel="Epoch"></Plot>
                <div class="row" style="margin-left: 0; margin-right: 0;">
                    <div class="col text-start">0</div>
                    <div class="col text-center">&Delta;@last_step_time</div>
                    <div class="col text-end">@total_training_time</div>
                </div>
            </figure>
            <figure>
                <figcaption>Results</figcaption>
                <div class="row">
                    <div class="col">
                        <button type="button" class="btn" @onclick=@(() => evaluate_loss())>&#8635;</button>
                    </div>
                    <div class="col" style="text-align: right;">
                        <button type="button" class="btn" style="text-decoration: underline;" @onclick=@(() => download_validation(last_results, "validation.json"))>json</button>
                    </div>
                </div>
                <div class="row">
                    <div class="col-sm">
                        <label class="summary-header">Tests</label>
                        <p title="passed: @last_results?.TestsPassedCount, failed: @last_results?.TestsFailedCount" class="summary-contents titled">@last_results?.TestsPassedCount/@(last_results?.TestCount)</p>
                    </div>
                    <div class="col-sm">
                        <label class="summary-header">Loss</label>
                        <p title="min: @last_results?.MinLoss, max: @last_results?.MaxLoss, avg: @last_results?.AverageLoss, function: @this.used_loss_function.Method.Name" class="summary-contents titled">@((last_results?.AverageLoss ?? 0.0).ToString("F2")) &plusmn; @(((last_results?.MaxLoss ?? 0.0 - last_results?.MinLoss ?? 0.0) / 2.0).ToString("F2"))</p>
                    </div>
                    <div class="col-sm">
                        <label class="summary-header">Step Duration</label>
                        <p title="min: @min_step_time, max: @max_step_time, avg: @(training_session is not null ? (total_training_time/Math.Max(1, training_session.CurrentEpoch)) : ((max_step_time + min_step_time) / 2.0)), last: @last_step_time" class="summary-contents titled">@max_step_time</p>
                    </div> 
                </div>
            </figure>
            @if(last_results is IValidationReportWithTestBreakdown breakdown) {
                var result_data = breakdown.TestBreakdown;
                <table class="table">
                    <thead>
                        <tr>
                            <th style="width: 2em;"></th>
                            <th>Input</th>
                            <th>Expected</th>
                            <th>Actual</th>
                            <th>Loss</th>
                        </tr>
                    </thead>
                    <tbody>
                            @foreach (var pair in result_data.Take(MAX_SET_DISPLAY_SIZE)){
                                <tr>
                                    <td>@if(pair.Loss <= ACCURACY_TOLERANCE) {<span class="green">&checkmark;</span>} else {<span class="red">&times;</span>}</td>
                                    @if(pair.Input.Dimensionality <= MAX_VECTOR_LENGTH) {
                                        <td title="@pair.Input" class="titled">@pair.Input</td>
                                    } else {
                                        <td>[...]</td>
                                    }
                                    @if (pair.Expected.Dimensionality <= MAX_VECTOR_LENGTH) {
                                        <td title="@pair.Expected" class="titled">@pair.Expected</td>
                                    } else {
                                        <td>[...]</td>
                                    }
                                    @if (pair.Predicted.Dimensionality <= MAX_VECTOR_LENGTH) {
                                        <td title="@pair.Predicted" class="titled">@pair.Predicted</td>
                                    } else {
                                        <td>[...]</td>
                                    }
                                    <td title="@pair.Loss" class="titled">@pair.Loss.ToString("F8")</td>
                                </tr>
                            }
                    </tbody>
                </table>
                if (breakdown.TestCount > MAX_SET_DISPLAY_SIZE) {
                    <p>Validation set contains @breakdown.TestCount test pairs which is too large for all of them to be displayed. Download the test results data via the get button above to view all tests.</p>
                }
            }
            @if (ValidationVisualization is not null && Network is not null && last_results is not null) {
                @ValidationVisualization((Network, last_results));
            }
        </div>
    </div>
</div>
} else {
<div class="row p-4"> 
    <div class=col-sm-6>
        <label class="header">Input</label>
        @if (UseDefaultEval) {
        <p>
            Enter your input vector below. You may enter the vector's values directly by typing a double[] into the JSON field below. Additionally, some helpful controls may also be provided below to manipulate the input vector.
        </p>
        <label>JSON:</label>
        <textarea bind="input_json" class="form-control" @bind=input_json></textarea>
        }
        @if (Input is not null) {
            <label style="margin-top: 6px;">Controls:</label>
            @Input(this.input_vector)
        }
    </div>
    <div class=col-sm-6>
        <label class="header">Output</label>
        @if (UseDefaultEval) {
        <p>
            After you have entered your input vector on the left, press the button below to have the network process the input and show you the results.
        </p>
        <button type="button" class="btn btn-primary" style="width: 100%" @onclick=process>Process Input</button>
        }
        @if (process_error is not null) {
            <div class="alert alert-danger" role="alert" style="margin-top: 12px; margin-bottom: 12px;">
                @process_error
            </div>
        }
        <div>
            @if (Output is not null) {
                @Output((input_vector, output_vector))
            }
        </div>
    </div>
</div>
}

@code {
    const int MAX_SET_DISPLAY_SIZE = 10;
    const int MAX_VECTOR_LENGTH = 1024;

    [Parameter] public bool UseDefaultEval {get; set;} = true;

    [Parameter] public TNetwork? Network {get; set;} = default(TNetwork);
    [Parameter] public TrainingSet? TrainingData {get; set;}
    [Parameter] public TrainingSet? ValidationData {get; set;}
    private TrainingSet? validation_data => ValidationData ?? TrainingData;

    enum State {
        Playground, Training
    }
    private State _current;
    private State state {
        get => _current;
        set {
            _current = value;
            step_timer?.Stop();
        }
    }

    public void RefreshState() {
        this.StateHasChanged();
    }
    private async void download_str(string data, string name = "data.json") {
        if (data is null)
            return;
        await js.InvokeVoidAsync("BlazorComponents.Files.download", name, "text/json", System.Text.Encoding.UTF8.GetBytes(data));
    }
    private async void download_bytes(byte[] data, string name = "data.json") {
        if (data is null)
            return;
        await js.InvokeVoidAsync("BlazorComponents.Files.download", name, "application/octet-stream", data);
    }
    private async void download_validation(IValidationReport? data, string name = "data.json") {
        if (data is null)
            return;
        var json = data is IValidationReportWithTestBreakdown br ? JsonSerializer.Serialize(br) : JsonSerializer.Serialize(data);
        await js.InvokeVoidAsync("BlazorComponents.Files.download", name, "text/json", System.Text.Encoding.UTF8.GetBytes(json));
    }
    private async void download<T>(T data, string name = "data.json") {
        if (data is null)
            return;
        var json = JsonSerializer.Serialize(data);
        await js.InvokeVoidAsync("BlazorComponents.Files.download", name, "text/json", System.Text.Encoding.UTF8.GetBytes(json));
    }
    private void download_binary(TrainingSet? data, string name = "vectors.bin") {
        if (data is null)
            return;
        Task.Run(async () => {
            var stream = new MemoryStream();
            var writer = new BinaryWriter(stream);
            data.WriteTo(writer);
            await js.InvokeVoidAsync("BlazorComponents.Files.download", name, "application/octet-stream", stream.ToArray());
        });
    }

    #region Playground
    private Box<Vec<double>> input_vector = new Box<Vec<double>>(new Vec<double>());
        private string input_json {
        get => System.Text.Json.JsonSerializer.Serialize((double[])input_vector.Value);
        set {
            try {
                input_vector.Value = System.Text.Json.JsonSerializer.Deserialize<double[]>(value) ?? new double[0];
            } catch {
                // Do nothing? maybe record the error somewhere in case someone put bad data in.
            }
        }
    }
    [Parameter] public RenderFragment<Box<Vec<double>>>? Input {get; set;}
     private Box<Vec<double>> output_vector = new Box<Vec<double>>(new Vec<double>());
    [Parameter] public RenderFragment<(Box<Vec<double>> Input, Box<Vec<double>> Output)>? Output {get; set;}
    private Exception? process_error;
    private void process() {
        process_error = null;

        if (Network is null) {
            process_error = new NullReferenceException(nameof(Network));
            return;
        }

        try {
            output_vector.Value = Network.PredictSync(input_vector.Value);
        } catch (Exception e) {
            process_error = e;
            return;
        }
    }

    public Vec<double>? Process(Vec<double> input) {
        process_error = null;

        if (Network is null) {
            process_error = new NullReferenceException(nameof(Network));
            return null;
        }

         try {
            input_vector.Value = input;
            var outvec = Network.PredictSync(input);
            output_vector.Value = outvec;
            return outvec;
        } catch (Exception e) {
            process_error = e;
            return null;
        }
    }
    #endregion

    #region Training
    [Parameter] public IEnumerableTrainer<TNetwork>? Trainer {get; set;}
    [Parameter] public RenderFragment<TrainingSet>? DataVisualization {get; set;}
    [Parameter] public RenderFragment<TNetwork>? NetworkVisualization {get; set;}
    [Parameter] public RenderFragment<(TNetwork Network, IValidationReport? Validation)>? ValidationVisualization {get; set;}
    [Parameter] public RenderFragment<(TNetwork Network, IEnumerableTrainer<TNetwork> Trainer)>? TrainingParams {get; set;}
    
    private IValidationReport? last_results;

    private IEpochEnumerator<TNetwork>? training_session;
    private TrainingProgress? training_progress;
    private Timer? step_timer;
    private TimeSpan max_step_time = TimeSpan.Zero;
    private TimeSpan min_step_time = TimeSpan.Zero;
    private TimeSpan last_step_time = TimeSpan.Zero;
    private TimeSpan total_training_time = TimeSpan.Zero;
    private Stopwatch stopwatch = new Stopwatch();
    private List<(double X, double Y)> loss_graph = new List<(double X, double Y)>(500);
    private Exception? step_error;
    [Parameter] public int? MaxEpochSize {get; set;}
    private void reset_training() {
        step_timer?.Stop(); 
        loss_graph.Clear();
        total_training_time = TimeSpan.Zero;
        max_step_time = TimeSpan.Zero;
        min_step_time = TimeSpan.Zero;

        // TODO configure trainer
        if (Trainer is null)
            return;

        // TODO Configure network
        if (Network is null)
            return;

        // Start training
        if (TrainingData is null || validation_data is null)
            return;

        //var sampled_count = Math.Min(200, TrainingData.Size);
        //TrainingData.SampleRandomly(sampled_count), // Only use a max of 200 samples per epoch
        var training = MaxEpochSize.HasValue ? TrainingData.SampleRandomly(Math.Min(MaxEpochSize.Value, TrainingData.Size)) : TrainingData.SampleRandomly();
        training_session = Trainer.EnumerateTraining(
            Network, 
            training, 
            validation_data.SampleSequentially()
        );
        training_session.OnBatchEnd += (batchIndex, batchCount) => training_progress?.UpdateBatchAsync(batchIndex + 1, batchCount);
        training_session.OnValidationStart += (epoch, maxEpochs) => training_progress?.UpdateValidatedAsync(0, validation_data?.Size ?? 0);
        training_session.OnValidated += (epoch, maxEpochs, inputIndex, loss) => training_progress?.UpdateValidatedAsync(inputIndex + 1, validation_data?.Size ?? 0);
        training_session.OnEpochEnd += (epoch, maxEpochs) => save_session(epoch);

        training_progress?.Update(0, 0, 0, validation_data?.Size ?? 0, training_session.CurrentEpoch, training_session.MaxEpochs);
    }

    [Parameter] public ICheckpointManager<TNetwork>? Checkpoint {get; set;}
    public bool AllowSessionResuming => Checkpoint is not null;
    private void save_session(int epoch) {
        if (!AllowSessionResuming || Network is null)
            return;
        
        Checkpoint?.CreateCheckpoint(this.Network);
    }
    private bool does_prev_session_exist() {
        return Checkpoint?.ListCheckpoints()?.Any() ?? false;
    }
    protected override async Task OnAfterRenderAsync(bool first) {
        if (first && does_prev_session_exist()) {
            await restore_prev_session();
        }
    }
    private async Task restore_prev_session() {
        if (Network is null || Checkpoint is null) {
            return;
        }

        // Get all saved checkpoints
        var most_recent = Checkpoint.ListCheckpoints().OrderByDescending(x => x.Created);
        if (!most_recent.Any())
            return;

        // Prompt user to select a checkpoint
        var options = string.Join('\n', most_recent.Select((c,i) => (i + 1).ToString() + ". " + c.Name));
        var first = most_recent.FirstOrDefault();
        var name = await js.InvokeAsync<string>("prompt", "Restore a training session.\n\n" + options + "\n\nLeave blank to not restore any session.", first?.Name);
        var selected = most_recent.Where(c => c.Name == name).FirstOrDefault();

        if (selected is null)
            return;

        // Start a new training session, but restore the weights of the checkpoint
        try {
            reset_training();
            Checkpoint.RestoreFromCheckpoint(this.Network, selected);
            await js.InvokeVoidAsync("alert", "Training session successfully restored.");
        } catch (Exception e) {
            Console.WriteLine(e);
            await js.InvokeVoidAsync("alert", "An error occurred while loading checkpoint.");
        }
    }

    private void play_pause() {
        if (step_timer is null || !step_timer.Enabled) {
            play();
        } else {
            pause();
        }
    }

    private void play() {
        if (training_session is null) {
            reset_training();
        }

        if (step_timer is null || !step_timer.Enabled) {
            if (step_timer is null) {
                step_timer = new Timer(250);
                step_timer.Elapsed += onTrainingStepElapsed;
            }
            step_error = null;
            step_timer.Start();
        } 
    }

    private void pause() {
        step_timer?.Stop();
    }

    private void cancel_training() {
        step_timer?.Stop();
        training_session = null;
    }

    private void onTrainingStepElapsed(object? sender, ElapsedEventArgs e) {
        step_timer?.Stop();
        if (training_session is null) {
            return;
        }

        stopwatch.Reset();
        stopwatch.Start();
        bool has_next = false;
        try {
            has_next = training_session.MoveNext();
            training_progress?.UpdateAsync(0, 0, 0, validation_data?.Size ?? 0, training_session.CurrentEpoch, training_session.MaxEpochs);
        } catch (Exception ex) {
            step_timer?.Stop();
            training_session = null;
            step_error = ex;
            InvokeAsync(StateHasChanged);
            return;
        } finally {
            stopwatch.Stop();
            last_step_time = stopwatch.Elapsed;
            total_training_time += stopwatch.Elapsed;
            if (max_step_time < stopwatch.Elapsed) {
                max_step_time = stopwatch.Elapsed;
            }
            if (min_step_time == TimeSpan.Zero || stopwatch.Elapsed < min_step_time) {
                min_step_time = stopwatch.Elapsed;
            }
        }

        if (!has_next) {
            // No next step
            loss_graph.Add((training_session.CurrentEpoch, evaluate_loss()));
            Checkpoint?.ClearCheckpoints();
        } else {
            // Next step
            loss_graph.Add((training_session.CurrentEpoch, evaluate_loss()));
            step_timer?.Start();
        }

        InvokeAsync(StateHasChanged);
    }

    private void step_training() {
        step_timer?.Stop();
        if (training_session is null) {
            return;
        }
        
        stopwatch.Reset();
        stopwatch.Start();
        bool has_next = false;
        try {
            has_next = training_session.MoveNext();
            training_progress?.Update(0, 0, 0, validation_data?.Size ?? 0, training_session.CurrentEpoch, training_session.MaxEpochs);
        } catch (Exception ex) {
            step_timer?.Stop();
            training_session = null;
            step_error = ex;
            return;
        } finally {
            stopwatch.Stop();
            last_step_time = stopwatch.Elapsed;
            total_training_time += stopwatch.Elapsed;
            if (max_step_time < stopwatch.Elapsed) {
                max_step_time = stopwatch.Elapsed;
            }
            if (min_step_time == TimeSpan.Zero || stopwatch.Elapsed < min_step_time) {
                min_step_time = stopwatch.Elapsed;
            }
        }

        if (!has_next) {
            // No next step
            loss_graph.Add((training_session.CurrentEpoch, evaluate_loss()));
            Checkpoint?.ClearCheckpoints();
        } else {
            // Next step
            loss_graph.Add((training_session.CurrentEpoch, evaluate_loss()));
        }
    }

    private void complete_training() {
        step_timer?.Stop();

        if (training_session is null) {
            reset_training();
        }
        if (Network is null || TrainingData is null)
            return;

        stopwatch.Reset();
        stopwatch.Start();
        training_session?.MoveToEnd();
        stopwatch.Stop();
        last_step_time = stopwatch.Elapsed;
        total_training_time += stopwatch.Elapsed;

        evaluate_loss();
        Checkpoint?.ClearCheckpoints();
    }

    const double ACCURACY_TOLERANCE = 0.1;
    private LossFunction used_loss_function => training_session?.GetType()?.GetProperties()?.Where(p => p.PropertyType.IsAssignableTo(typeof(LossFunction)))?.Select(p => (LossFunction?)p.GetValue(training_session)).FirstOrDefault() ?? LossFunctions.MeanSquaredError;
    private double evaluate_loss() {
        var report = Trainer?.ValidationReport;
        if (report is null) {
            this.last_results = null;
            return 0;
        } else {
            this.last_results = report;
            return report.AverageLoss;            
        }
    }

    public void Dispose() {
        step_timer?.Stop();
        step_timer?.Dispose();
    }
    #endregion
}